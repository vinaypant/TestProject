View encapsulation

*******************
Shadow DOM

****************
@ViewChild(HelloComponent, {static: false})

ViewChild vs ViewChildren vs ContentChild vs Contentchildren
https://www.divami.com/blog/simplifying-viewchild-and-contentchild-in-angular-10

http://www.mtutorial.com/angular-viewchild-viewchildren-contentchild-contentchildren-example
******************
Dynamic component Loading

***************
Life cycle hooks

https://indepth.dev/posts/1494/complete-guide-angular-lifecycle-hooks

****************
Pipes let us render items in component templates in the way we want.

There are two kinds of pipes in Angular—pure and impure pipes. A pure pipe is a pipe that is
run when a primitive JavaScript input value like strings, numbers, booleans, symbols or an object 
reference change.

Pure pipes must be pure functions. Pure functions take an input and return an output. 
They don’t have side effects. Changes within objects are ignored with pure pipes. When any 
changes take place, the pipe will run and the latest change will be rendered.

Impure pipes are pipes that can detect changes within objects and arrays.


******************************

Pure pipes are the pipes which are executed only when a “PURE CHANGE” to the input value
is detected.

So impure pipe executes everytime irrespective of source has changed or not. 
which leads to bad performance. thats why it is not recommneded to use pipes for filtering
data.


******************************

We use the @Inject parameter decorator to instruct Angular we want to resolve a token and
inject a dependency into a constructor.

We use the @Injectable class decorators to automatically resolve and inject all the 
parameters of class constructor.

Its better to use @Injectable rather than @Inject , because in case of inject we will have to
use inject that many times

class SimpleService {
  otherService: OtherService;

  constructor(@Inject(OtherService) otherService: OtherService) {
      this.otherService = otherService;
  };
}

@Injectable()
class SimpleService {
  otherService: OtherService;

  constructor(otherService: OtherService) {
      this.otherService = otherService;
  };
}

other decorators in Angular, such as @Component and @Directive, 
already perform the same function as @Injectable


******************************

@Inject()
is a manual mechanism for letting Angular know that a parameter must be injected.

When using TypeScript, @Inject is only needed for injecting primitives. For eg:

export class AppComponent {
  encryption = this.chatWidget.chatSocket.encryption;

  constructor(@Inject(ChatWidget) private chatWidget) { }
}
@Injectable()
lets Angular know that a class can be used with the dependency injector.

For eg:

@Injectable()
export class ChatWidget {
constructor(
    public authService: AuthService,
    public authWidget: AuthWidget,
    public chatSocket: ChatSocket) { }
}

******************************



